worker_processes  1;

events {
	worker_connections 1024;
}

http {
	lua_shared_dict rate_limit_store 10m;

	set_real_ip_from 0.0.0.0/0;
	real_ip_header X-Forwarded-For;
	real_ip_recursive on;

	server {
		listen 80;
		server_name _;

		location / {
			access_by_lua_block {
				local limit_store = ngx.shared.rate_limit_store
				local ip = ngx.var.remote_addr
				local now = ngx.now()

				-- Configurable thresholds
				local base_delay = 2	-- seconds
				local max_delay = 60	-- seconds
				local window = 30		-- seconds tracking window
				local limit = 20		-- number of allowed requests per window

				local reqs, err = limit_store:get(ip)
				if not reqs then
					limit_store:set(ip, 1, window)
				elseif reqs < limit then
					limit_store:incr(ip, 1)
				else
					-- Exponential delay mechanism
					local penalty_key = ip .. "_penalty"
					local strikes = limit_store:get(penalty_key) or 0
					strikes = strikes + 1
					limit_store:set(penalty_key, strikes, max_delay)

					local delay = math.min(base_delay * (2 ^ (strikes - 1)), max_delay)
					ngx.header["Retry-After"] = delay
					ngx.status = 429
					ngx.say("Rate limit exceeded. Retry in " .. delay .. " seconds.")

					-- Log the blocked IP with delay info
					ngx.log(ngx.WARN, "Rate limit block: IP ", ip, " blocked for ", delay, " seconds (strike ", strikes, ")")

					return ngx.exit(429)
				end
			}

			# Proxy the request to your backend web service
			proxy_pass http://web:80;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		}
	}
}
