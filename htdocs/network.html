<!DOCTYPE html>
<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.css" />
<style>
	.chart-container {
		width: fit-content;
		margin: 0;
		padding: 0;
		text-align: left;
		display: block;
	}

	.Treant > p {
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-weight: bold;
		font-size: 12px;
	}

	.node {
		width: 200px;
		padding: 10px;
		border: 1px solid #000;
		border-radius: 8px;
		background-color: #fff;
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-size: 12px;
	}

	.node-title {
		font-weight: bold;
		font-size: 12px;
	}

	.node-serial,
	.node-ssid,
	.node-rssi {
		font-size: 12px;
		padding-top: 4px;
	}

	.node-version {
		font-size: 10px;
		padding-top: 4px;
	}

	.red {
		background-color: #ff0000;
	}
	.yellow {
		background-color: #ffff00;
	}
	.green {
		background-color: #00ff00;
	}
	.root-node {
		padding-bottom: 40px;
	}

	/* Floating search bar */
	#search-bar-container {
		position: fixed;
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		z-index: 999;
		background-color: white;
		padding: 10px 20px;
		border: 1px solid #ccc;
		border-radius: 10px;
		box-shadow: 0 0 10px rgba(0,0,0,0.1);
	}
	#search-bar {
		font-size: 14px;
		width: 300px;
	}
</style>
</head>
<body>
<div id="trees">Loading...</div>

<div id="search-bar-container">
	<input type="text" id="search-bar" placeholder="Search..." />
</div>

<script>
	let originalTreeData = [];

	function createClientNode(client) {
		const meter = client.meter || {};
		const nameText = meter.info || "Client";
		const serial = meter.serial || 'N/A';
		const ssid = meter.ssid || 'N/A';
		const rssi = meter.rssi || 'N/A';
		const swVersion = meter.sw_version || 'N/A';
		const lastUpdated = meter.last_updated;

		let freshnessClass = 'green';
		if (lastUpdated) {
			const updatedTime = new Date(lastUpdated * 1000);
			const ageHours = (Date.now() - updatedTime.getTime()) / (1000 * 60 * 60);

			if (ageHours < 1) freshnessClass = 'green';
			else if (ageHours < 24) freshnessClass = 'yellow';
			else freshnessClass = 'red';
		}

		const htmlContent = `
			<div class="node-title">${nameText}</div>
			<div class="node-serial"><b>serial:</b> ${serial}</div>
			<div class="node-ssid"><b>ssid:</b> ${ssid}</div>
			<div class="node-rssi"><b>rssi:</b> ${rssi}</div>
			<div class="node-version"><b>version:</b> ${swVersion}</div>
		`;

		let children = [];
		if (client.clients && client.clients.length) {
			children = client.clients.map(createClientNode);
		}

		return {
			HTMLclass: `node ${freshnessClass}`,
			innerHTML: htmlContent,
			children: children
		};
	}

	function extractNodeTitleText(innerHTML) {
		if (!innerHTML) return null;
		const div = document.createElement('div');
		div.innerHTML = innerHTML;
		const titleDiv = div.querySelector('.node-title');
		return titleDiv ? titleDiv.textContent.trim() : null;
	}

	function sortTreeNodes(node) {
		if (node.children && node.children.length > 0) {
			node.children.sort((a, b) => {
				const nameA = (a.text?.name) || extractNodeTitleText(a.innerHTML) || "";
				const nameB = (b.text?.name) || extractNodeTitleText(b.innerHTML) || "";
				return nameA.toLowerCase().localeCompare(nameB.toLowerCase());
			});
			node.children.forEach(child => sortTreeNodes(child));
		}
	}

	function createTreeConfig(routerObj, index) {
		const routerName = routerObj.router?.name || "Router";

		const rootNode = {
			HTMLclass: 'node green root-node',
			innerHTML: `<div class="node-title">${routerName}</div>`,
			children: []
		};

		if (routerObj.clients && routerObj.clients.length) {
			rootNode.children = routerObj.clients.map(createClientNode);
		}

		sortTreeNodes(rootNode);

		return {
			chart: {
				container: `#tree${index}`,
				rootOrientation: 'WEST',
				levelSeparation: 50,
				siblingSeparation: 50,
				subTeeSeparation: 30
			},
			nodeStructure: rootNode
		};
	}

	async function fetchAndRenderTrees() {
		try {
			const response = await fetch('/api/meters/tree');
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

			const data = await response.json();
			originalTreeData = data;

			data.sort((a, b) => {
				const nameA = (a.router?.name || "Router").toLowerCase();
				const nameB = (b.router?.name || "Router").toLowerCase();
				return nameA.localeCompare(nameB);
			});

			renderTrees(data);
		} catch (err) {
			document.getElementById('trees').innerText = 'Failed to load tree data: ' + err.message;
			console.error(err);
		}
	}

	function renderTrees(data) {
		const container = document.getElementById('trees');
		container.innerHTML = '';

		data.forEach((routerObj, i) => {
			const treeDiv = document.createElement('div');
			treeDiv.id = `tree${i}`;
			treeDiv.className = 'chart-container';
			container.appendChild(treeDiv);

			const config = createTreeConfig(routerObj, i);
			new Treant(config);
		});
	}

	function filterTree(treeData, query) {
		const lowerQuery = query.toLowerCase();

		function nodeMatches(meter) {
			return meter?.info?.toLowerCase().includes(lowerQuery)
				|| meter?.serial?.toLowerCase().includes(lowerQuery)
				|| meter?.ssid?.toLowerCase().includes(lowerQuery);
		}

		function filterClients(clients) {
			const result = [];

			for (const client of clients) {
				const children = filterClients(client.clients || []);
				if (nodeMatches(client.meter) || children.length > 0) {
					result.push({ ...client, clients: children });
				}
			}
			return result;
		}

		return treeData.map(router => {
			const matchedClients = filterClients(router.clients || []);
			return {
				...router,
				clients: matchedClients
			};
		}).filter(router => router.clients.length > 0);
	}

	function debounce(fn, delay) {
		let timeout;
		return function (...args) {
			clearTimeout(timeout);
			timeout = setTimeout(() => fn.apply(this, args), delay);
		};
	}

	const renderFilteredTrees = debounce(function () {
		const query = document.getElementById('search-bar').value.trim();
		const filteredData = query
			? filterTree(originalTreeData, query)
			: originalTreeData;

		renderTrees(filteredData);
	}, 300);

	document.getElementById('search-bar').addEventListener('input', renderFilteredTrees);

	fetchAndRenderTrees();
</script>
</body>
</html>
