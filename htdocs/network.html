<!DOCTYPE html>
<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.css" />
<style>
	.chart-container {
		width: fit-content;  /* shrink to content width */
		margin: 0;           /* no margin */
		padding: 0;          /* no padding */
		text-align: left;    /* align content left */
		display: inline-block; /* prevents full-width block */
	}
	

	/* General font for Treant paragraphs */
	.Treant > p {
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-weight: bold;
		font-size: 12px;
	}

	/* Node styling */
	.node {
		width: 200px;
		padding: 10px;
		border: 1px solid #000;
		border-radius: 3px;
		background-color: #fff;
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-size: 12px;
	}

	/* Specific node text styles */
	.node-title {
		font-weight: bold;
		font-size: 12px;
	}

	.node-ssid {
		font-size: 12px;
		padding-top: 4px;
	}

	.node-rssi {
		font-size: 12px;
	}

	.node-version {
		font-size: 10px;
	}
</style>
</head>
<body>
<div id="trees">Loading tree data...</div>

<script>
	// Recursive function to create Treant nodes for clients and nested clients
	function createClientNode(client) {
		const meter = client.meter || {};
		const name = meter.info ? `${meter.info} (Serial: ${meter.serial || 'N/A'})` : "Client";

		let children = [];
		if (client.clients && client.clients.length) {
			children = client.clients.map(createClientNode);
		}

		return {
			text: { name },
			children: children
		};
	}

	// Recursive function to sort nodes by their text.name
	function sortTreeNodes(node) {
		if (node.children && node.children.length > 0) {
			node.children.sort((a, b) => {
				const nameA = a.text.name.toLowerCase();
				const nameB = b.text.name.toLowerCase();
				return nameA.localeCompare(nameB);
			});
			node.children.forEach(child => sortTreeNodes(child));
		}
	}

	// Convert each router object into Treant config
	function createTreeConfig(routerObj, index) {
		const routerName = routerObj.router?.name || "Router";

		// Root node is the router
		const rootNode = {
			text: { name: `Router: ${routerName}` },
			children: []
		};

		// Add top-level clients recursively
		if (routerObj.clients && routerObj.clients.length) {
			rootNode.children = routerObj.clients.map(createClientNode);
		}

		// Sort children of root node recursively
		sortTreeNodes(rootNode);

		return {
			chart: {
				container: `#tree${index}`,
				rootOrientation: 'WEST',
				levelSeparation: 50,	 // distance between generations vertically
				siblingSeparation: 50, // distance between siblings horizontally
				subTeeSeparation: 30	 // distance between subtrees
			},
			nodeStructure: rootNode
		};
	}

	async function fetchAndRenderTrees() {
		try {
			const response = await fetch('/api/meters/tree');
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

			const data = await response.json();

			// Sort routers by their name (case-insensitive)
			data.sort((a, b) => {
				const nameA = (a.router?.name || "Router").toLowerCase();
				const nameB = (b.router?.name || "Router").toLowerCase();
				return nameA.localeCompare(nameB);
			});

			const container = document.getElementById('trees');
			container.innerHTML = '';	// clear loading text

			data.forEach((routerObj, i) => {
				// Create div for each tree
				const treeDiv = document.createElement('div');
				treeDiv.id = `tree${i}`;
				treeDiv.className = 'chart-container';
				container.appendChild(treeDiv);

				// Create Treant config (which sorts clients internally)
				const config = createTreeConfig(routerObj, i);

				// Render tree
				new Treant(config);
			});

		} catch (err) {
			document.getElementById('trees').innerText = 'Failed to load tree data: ' + err.message;
			console.error(err);
		}
	}

	fetchAndRenderTrees();
</script>

</body>
</html>
