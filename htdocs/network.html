<!DOCTYPE html>
<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.css" />
<style>
	.chart-container {
		width: fit-content;  /* shrink to content width */
		margin: 0;           /* no margin */
		padding: 0;          /* no padding */
		text-align: left;    /* align content left */
		display: inline-block; /* prevents full-width block */
	}
	

	/* General font for Treant paragraphs */
	.Treant > p {
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-weight: bold;
		font-size: 12px;
	}

	/* Node styling */
	.node {
		width: 200px;
		padding: 10px;
		border: 1px solid #000;
		border-radius: 8px;
		background-color: #fff;
		font-family: "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-size: 12px;
	}

	/* Specific node text styles */
	.node-title {
		font-weight: bold;
		font-size: 12px;
	}

	.node-serial{
		font-size: 12px;
		padding-top: 4px;
	}

	.node-ssid {
		font-size: 12px;
		padding-top: 4px;
	}

	.node-rssi {
		font-size: 12px;
		padding-top: 4px;
	}

	.node-version {
		font-size: 10px;
		padding-top: 4px;
	}
	
	.red {
		background-color: #ff0000;
	}

	.yellow {
		background-color: #ffff00;
	}

	.green {
		background-color: #00ff00;
	}
	
	.root-node {
		padding-bottom: 40px;
	}	
</style>
</head>
<body>
<div id="trees"></div>

<script>
	// Recursive function to create Treant nodes for clients and nested clients
	function createClientNode(client) {
		const meter = client.meter || {};
		const nameText = meter.info || "Client";
		const serial = meter.serial || 'N/A';
		const ssid = meter.ssid || 'N/A';
		const rssi = meter.rssi || 'N/A';
		const swVersion = meter.sw_version || 'N/A';
		const lastUpdated = meter.last_updated;

		// Determine recency class
		let freshnessClass = 'green'; // default
		if (lastUpdated) {
			const updatedTime = new Date(lastUpdated * 1000);
			const ageHours = (Date.now() - updatedTime.getTime()) / (1000 * 60 * 60);

			if (ageHours < 1) freshnessClass = 'green';
			else if (ageHours < 24) freshnessClass = 'yellow';
			else freshnessClass = 'red';
		}

		const htmlContent = `
			<div class="node-title">${nameText}</div>
			<div class="node-serial"><b>serial:</b> ${serial}</div>
			<div class="node-ssid"><b>ssid:</b> ${ssid}</div>
			<div class="node-rssi"><b>rssi:</b> ${rssi}</div>
			<div class="node-version"><b>version:</b> ${swVersion}</div>
		`;

		let children = [];
		if (client.clients && client.clients.length) {
			children = client.clients.map(createClientNode);
		}

		return {
			HTMLclass: `node ${freshnessClass}`,
			innerHTML: htmlContent,
			children: children
		};
	}
	

	// Recursive function to sort nodes by their text.name or innerHTML .node-title text
	function sortTreeNodes(node) {
		if (node.children && node.children.length > 0) {
			node.children.sort((a, b) => {
				// Extract text for sorting: prefer text.name, fallback to innerHTML title div content
				const nameA = (a.text?.name) || extractNodeTitleText(a.innerHTML) || "";
				const nameB = (b.text?.name) || extractNodeTitleText(b.innerHTML) || "";
				return nameA.toLowerCase().localeCompare(nameB.toLowerCase());
			});
			node.children.forEach(child => sortTreeNodes(child));
		}
	}

	// Helper to extract the name from innerHTML node-title div (used only during sort)
	function extractNodeTitleText(innerHTML) {
		if (!innerHTML) return null;
		const div = document.createElement('div');
		div.innerHTML = innerHTML;
		const titleDiv = div.querySelector('.node-title');
		return titleDiv ? titleDiv.textContent.trim() : null;
	}

	// Convert each router object into Treant config
	function createTreeConfig(routerObj, index) {
		const routerName = routerObj.router?.name || "Router";

		// Root node is the router
		const rootNode = {
			HTMLclass: 'node green root-node',
			innerHTML: `<div class="node-title">${routerName}</div>`,
			children: []
		};

		// Add top-level clients recursively
		if (routerObj.clients && routerObj.clients.length) {
			rootNode.children = routerObj.clients.map(createClientNode);
		}

		// Sort children of root node recursively
		sortTreeNodes(rootNode);

		return {
			chart: {
				container: `#tree${index}`,
				rootOrientation: 'WEST',
				levelSeparation: 50,	 // distance between generations vertically
				siblingSeparation: 50, // distance between siblings horizontally
				subTeeSeparation: 30	 // distance between subtrees
			},
			nodeStructure: rootNode
		};
	}

	async function fetchAndRenderTrees() {
		try {
			const response = await fetch('/api/meters/tree');
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

			const data = await response.json();

			// Sort routers by their name (case-insensitive)
			data.sort((a, b) => {
				const nameA = (a.router?.name || "Router").toLowerCase();
				const nameB = (b.router?.name || "Router").toLowerCase();
				return nameA.localeCompare(nameB);
			});

			const container = document.getElementById('trees');
			container.innerHTML = '';	// clear loading text

			data.forEach((routerObj, i) => {
				// Create div for each tree
				const treeDiv = document.createElement('div');
				treeDiv.id = `tree${i}`;
				treeDiv.className = 'chart-container';
				container.appendChild(treeDiv);

				// Create Treant config (which sorts clients internally)
				const config = createTreeConfig(routerObj, i);

				// Render tree
				new Treant(config);
			});

		} catch (err) {
			document.getElementById('trees').innerText = 'Failed to load tree data: ' + err.message;
			console.error(err);
		}
	}

	fetchAndRenderTrees();
</script>

</body>
</html>
