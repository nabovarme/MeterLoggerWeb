<!DOCTYPE html>
<html lang="en">
<head>
	<meta name="robots" content="noindex">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MeterLogger Snooze Alarm</title>
	<style>
		body {
			font-family: Verdana, Geneva, sans-serif;
			padding: 20px;
		}
		#status {
			margin-bottom: 20px;
			font-weight: bold;
		}
		/* Hide slider initially until first fetch */
		label {
			display: none;
			margin-top: 20px;
		}
		input[type=range] {
			width: 100%;
			max-width: 100%;
			box-sizing: border-box;
		}
		#durationDisplay {
			font-weight: bold;
			margin-left: 10px;
		}
	</style>
	<script>
		// Read auth token from raw query string (?<auth>)
		function getAuthFromQuery() {
			const qs = window.location.search;
			if (!qs || qs.length < 2) {
				return null;
			}
			return qs.substring(1); // strip leading '?'
		}

		// Format seconds to human-readable, whole numbers only
		function formatDuration(seconds) {
			if (seconds < 3600) {
				return Math.round(seconds / 60) + " min";
			} else if (seconds < 86400) {
				return Math.floor(seconds / 3600) + " hr";
			} else if (seconds < 604800) {
				return Math.floor(seconds / 86400) + " day";
			} else if (seconds < 2678400) {
				return Math.floor(seconds / 604800) + " week";
			} else if (seconds < 31536000) {
				return Math.floor(seconds / 2678400) + " month";
			} else {
				return Math.floor(seconds / 31536000) + " yr";
			}
		}

		// Snap seconds to nearest “display unit” for consistency
		function snapToFormatted(seconds) {
			if (seconds < 3600) return Math.round(seconds / 60) * 60;             // nearest min
			if (seconds < 86400) return Math.round(seconds / 3600) * 3600;        // nearest hr
			if (seconds < 604800) return Math.round(seconds / 86400) * 86400;     // nearest day
			if (seconds < 2678400) return Math.round(seconds / 604800) * 604800;  // nearest week
			if (seconds < 31536000) return Math.round(seconds / 2678400) * 2678400;// nearest month
			return Math.round(seconds / 31536000) * 31536000;                     // nearest year
		}

		// Convert slider value (0-100) to seconds using non-linear scale
		function sliderToSeconds(value) {
			const minSec = 60;        // 1 min
			const maxSec = 31536000;  // 1 yr
			const scale = value / 100;
			return Math.round(minSec * Math.pow(maxSec / minSec, scale));
		}

		// Convert seconds to slider value (inverse of sliderToSeconds)
		function secondsToSlider(seconds) {
			if (seconds <= 0) return 0;
			const minSec = 60;
			const maxSec = 31536000;
			return Math.log(seconds / minSec) / Math.log(maxSec / minSec) * 100;
		}

		// Fetch current snooze without updating
		async function fetchCurrentSnooze(auth) {
			const url = '/api/snooze/' + encodeURIComponent(auth);
			try {
				const res = await fetch(url);
				const data = await res.json();

				if (data.authorized && data.alarm && typeof data.alarm.snooze === 'number') {
					let snooze = data.alarm.snooze;
					if (snooze === 0 && typeof data.alarm.default_snooze === 'number') {
						snooze = data.alarm.default_snooze;
					}
					if (snooze <= 0) snooze = 1;
					return snapToFormatted(snooze); // snap to display unit
				} else {
					document.getElementById('status').textContent = data.error || "Not found";
					return 1800; // default 30 min
				}
			} catch (err) {
				console.error(err);
				document.getElementById('status').textContent = "Error contacting server";
				return 1800;
			}
		}

		// Call API to update snooze alarm
		function snoozeAlarm(auth, snooze) {
			if (!auth) {
				document.getElementById('status').textContent = "Missing auth key";
				return;
			}

			const url = '/api/snooze/' + encodeURIComponent(auth) + '/' + encodeURIComponent(snooze);
			fetch(url)
				.then(res => res.json())
				.then(data => {
					const container = document.getElementById('status');
					if (data.authorized) {
						container.textContent = "Alarm snoozed for " + (data.alarm.snooze_human || formatDuration(snooze)) + ".";
					} else {
						container.textContent = data.error || "Not found";
					}
				})
				.catch(err => {
					console.error(err);
					document.getElementById('status').textContent = "Error contacting server";
				});
		}

		// Triggered when slider changes (on release)
		function onSliderChange() {
			const auth = getAuthFromQuery();
			const slider = document.getElementById('snoozeSlider');
			let seconds = sliderToSeconds(parseInt(slider.value, 10));
			seconds = snapToFormatted(seconds); // snap to display unit
			document.getElementById('durationDisplay').textContent = formatDuration(seconds);
			snoozeAlarm(auth, seconds);
			slider.value = secondsToSlider(seconds); // update slider to snapped value
		}

		// Initialize slider after fetching current snooze
		window.addEventListener('DOMContentLoaded', async () => {
			const auth = getAuthFromQuery();
			if (!auth) {
				document.getElementById('status').textContent = "Missing auth key";
				return;
			}

			let currentSnooze = await fetchCurrentSnooze(auth);

			const slider = document.getElementById('snoozeSlider');
			const label = slider.parentElement;

			// Initialize slider
			slider.value = secondsToSlider(currentSnooze);
			document.getElementById('durationDisplay').textContent = formatDuration(currentSnooze);

			// Show slider after fetch
			label.style.display = "block";

			// Live update label while dragging
			slider.addEventListener('input', () => {
				let seconds = sliderToSeconds(parseInt(slider.value, 10));
				seconds = snapToFormatted(seconds);
				document.getElementById('durationDisplay').textContent = formatDuration(seconds);
			});

			// Call API only on release
			slider.addEventListener('change', onSliderChange);
		});
	</script>
</head>
<body>

<div id="status"></div>

<label>
	Snooze Duration: <span id="durationDisplay"></span>
	<input type="range" id="snoozeSlider" min="0" max="100" step="1">
</label>

</body>
</html>
